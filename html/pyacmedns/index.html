<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyacmedns API documentation</title>
<meta name="description" content="pyacmedns is a pure-Python ACME client specifically tailored to the DNS-01 challenge. This makes it easy to manage ACME
certificates and accounts â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pyacmedns</code></h1>
</header>
<section id="section-intro">
<p>pyacmedns is a pure-Python ACME client specifically tailored to the DNS-01 challenge. This makes it easy to manage ACME
certificates and accounts without the need for an external tool like <code>certbot</code>. Although this module is intended for use
with Let's Encrypt, it will support any CA utilizing the ACME protocol.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import OpenSSL
import datetime
import josepy as jose
import json
import pathlib
import time
import validators

from acme import challenges
from acme import client
from acme import crypto_util
from acme import messages
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa, ec
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption

from . import errors
from . import tools

__doc__ = &#34;&#34;&#34;
pyacmedns is a pure-Python ACME client specifically tailored to the DNS-01 challenge. This makes it easy to manage ACME 
certificates and accounts without the need for an external tool like `certbot`. Although this module is intended for use
with Let&#39;s Encrypt, it will support any CA utilizing the ACME protocol. 
&#34;&#34;&#34;


class ACMEClient:
    &#34;&#34;&#34;
    A basic ACME client object to interface with a CA using the ACME DNS-01 challenge.\n
    - :var `certificate` [`bytes`]: the PEM formatted certificate. This value is populated after successfully running
    the `request_certificate()` methood.\n
    - :var `private_key` [`bytes`]: the PEM formatted private key. This value is populated after successfully running
    the `generate_private_key()` method.\n
    - :var `csr` [`bytes`]: the PEM formatted certificate signing request. This value is populated after successfully
    running the `generate_csr()` method.\n
    &#34;&#34;&#34;

    def __init__(
            self, domains=None, email=None, directory=None, nameservers=None, new_account=False, generate_csr=False
    ):
        &#34;&#34;&#34;
        - :param `domains` [`list`]: FQDNs to list in the certificate (SANS).\n
        - :param `email` [`str`]: a valid email address to register new ACME accounts with.\n
        - :param `directory` [`str`]: the ACME directory URL.\n
        - :param `nameservers` [`list`]: nameservers to use when querying DNS. Defaults to system nameservers.\n
        - :param `new_account` [`bool`]: automatically register a new account upon object creation. A `directory` and
        `email` value will be required if True.\n
        - :param `generate_csr` [`bool`]: generate a new private key and CSR upon object creation. A `domains` value
        will be required if True.\n\n

        ## Example:\n
        ```python
        &gt;&gt;&gt; import pyacmedns
        &gt;&gt;&gt; client = pyacmedns.ACMEClient(
        ...     domains=[&#34;test1.example.com&#34;, &#34;test2.example.com&#34;],
        ...     email=&#34;example@example.com&#34;,
        ...     directory=&#34;https://acme-staging-v02.api.letsencrypt.org/directory&#34;,
        ...     nameservers=[&#34;8.8.8.8&#34;, &#34;1.1.1.1&#34;],
        ...     new_account=True,
        ...     generate_csr=True
        ... )
        ```

        &#34;&#34;&#34;
        self.DNS_LABEL = &#39;_acme-challenge&#39;
        self.domains = domains if domains else []
        self.email = email
        self.directory = directory
        self.certificate = &#39;&#39;.encode()
        self.private_key = &#39;&#39;.encode()
        self.csr = &#39;&#39;.encode()
        self.verification_tokens = []
        self.account_key = None
        self.account = None
        self.account_path = None
        self.nameservers = nameservers
        self.__private_key__ = None
        self.__client__ = None
        self.__net__ = None
        self.__directory__ = None
        self.__order__ = None
        self.__final_order__ = None
        self.__verification_tokens__ = []
        self.__responses__ = []
        self.__challenges__ = []
        self.__answers__ = []

        # Automatically create a new account if requested
        if new_account:
            self.new_account()
        # Automatically create a new private key and CSR
        if generate_csr:
            self.generate_private_key_and_csr()

    def generate_csr(self):
        &#34;&#34;&#34;
        Generates a new CSR using the object&#39;s `domains` and `private_key` values.\n
        - :return [`bytes`]: the encoded CSR PEM data string. This method will update the `csr` property of the object
        with the same value.\n
        - :raises `InvalidDomain`: when no valid `domains` are set.\n
        - :raises `InvalidPrivateKey`: when no `private_key` exists for this object.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.generate_csr()
        b&#39;-----BEGIN CERTIFICATE REQUEST-----\\nMIHxMIGZAgECMAAwWTATBgckjkn...&#39;
        ```
        &#34;&#34;&#34;
        self.__validate_domains__()
        self.__validate_private_key__()
        self.csr = crypto_util.make_csr(self.private_key, self.domains)
        return self.csr

    def generate_private_key(self, key_type=&#39;ec256&#39;):
        &#34;&#34;&#34;
        Generates a new RSA or EC private key.\n
        - :param `key_type` [`str`]: the requested `private_key` type. Options are: [`ec256`, `ec384`, `rsa2048`,
        `rsa4098`]\n
        - :return [`bytes`]: the encoded private key PEM data string. This method will update the `private_key` property
         of the object with the same value.\n
        - :raises `InvalidKeyType`: when an unknown/unsupported `key_type` is requested\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.generate_private_key(key_type=&#34;ec384&#34;)
        b&#39;-----BEGIN EC PRIVATE KEY-----\\nMIGkAgEBBDAZRFNLcQdVJmLh42p8F4D92...&#39;
        ```
        &#34;&#34;&#34;
        # Generate a EC256 private key
        if key_type == &#39;ec256&#39;:
            key = ec.generate_private_key(ec.SECP256R1(), default_backend())
            self.private_key = key.private_bytes(
                encoding=Encoding.PEM,
                format=PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=NoEncryption())
        # Generate a EC384 private key
        elif key_type == &#39;ec384&#39;:
            key = ec.generate_private_key(ec.SECP384R1(), default_backend())
            self.private_key = key.private_bytes(
                encoding=Encoding.PEM,
                format=PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=NoEncryption()
            )
        # Generate a RSA2048 private key
        elif key_type == &#39;rsa2048&#39;:
            key = OpenSSL.crypto.PKey()
            key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048)
            self.private_key = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
        # Generate a RSA4098 private key
        elif key_type == &#39;rsa4098&#39;:
            key = OpenSSL.crypto.PKey()
            key.generate_key(OpenSSL.crypto.TYPE_RSA, 4096)
            self.private_key = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
        # Otherwise, the requested key type is not supported. Throw an error
        else:
            options = [&#39;ec256&#39;, &#39;ec384&#39;, &#39;rsa2048&#39;, &#39;rsa4098&#39;]
            msg = &#34;Invalid private key rtype &#39;{key_type}&#39;. Options {options}&#34;.format(key_type=key_type, options=options)
            raise errors.InvalidKeyType(msg)
        return self.private_key

    def generate_private_key_and_csr(self, key_type=&#39;ec256&#39;):
        &#34;&#34;&#34;
        Generates a new private key and CSR.\n
        - :param `key_type` [`str`]: the requested `private_key` type. Options are: [`ec256`, `ec384`, `rsa2048`,
        `rsa4098`]\n
        - :return [`tuple`]: first value contains the key, the second value contains the CSR. This method will update
        the `private_key` and `csr` properties of this object with the same values.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.generate_private_key_and_csr(key_type=&#34;rsa2048&#34;)
        (b&#39;-----BEGIN PRIVATE KEY-----\\nMIIEvAIBA...&#39;, b&#39;-----BEGIN CERTIFICATE REQUEST-----\\nMIHxM...&#39;)
        ```
        &#34;&#34;&#34;
        self.generate_private_key(key_type=key_type)
        self.generate_csr()
        return self.private_key, self.csr

    def request_verification_tokens(self):
        &#34;&#34;&#34;
        Requests verification tokens from the ACME server for each `domains` value. These tokens must be uploaded as
        a DNS TXT record for each corresponding domain to complete verification.\n
        - :return [`list`]: a list of tuples containing the challenge FQDN and it&#39;s corresponding verification token.\n
        - :raises `InvalidAccount`: when account registration has not been set.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.request_verification_tokens()
        [
            (&#39;_acme-challenge.test1.example.com&#39;, &#39;moY32lkdsZ3VWHM1mdM...&#39;),
            (&#39;_acme-challenge.test2.example.com&#39;, &#39;asldfkjslweietj23_b...&#39;)
        ]
        ```
        &#34;&#34;&#34;
        self.__validate_registration__()
        self.__responses__ = []
        self.__verification_tokens__ = []
        self.__order__ = self.__client__.new_order(self.csr)
        self.__challenges__ = self.__verify_challenge__()

        # Loop through each of our challenges and extract the response and verification token from each
        for i, c in enumerate(self.__challenges__):
            response, validation = c.response_and_validation(self.__client__.net.key)
            self.__responses__.append(response)
            self.__verification_tokens__.append(validation)

        return self.__format_verification_tokens__()

    def request_certificate(self, wait=0, timeout=90):
        &#34;&#34;&#34;
        Requests a final verification answer from the ACME server and requests the certificate if verification was
        successful. If you request the certificate before DNS has propagated and verification fails, you must start
        the verification process over entirely by requesting new verification tokens.\n
        - :param `wait` [`int`]: amount of time (in seconds) to wait before requesting a challenge answer from the
        server. This is only necessary if you are not using the `check_dns_propagation()` method to verify the DNS
        records exist and would rather wait a specific amount of time.\n
        - :return [`bytes`]: the PEM encoded certificate. This method will update the `certificate` and `csr` property
        of this object with the same value.\n
        - :raises `InvalidAccount`:  when account registration has not been set.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.request_certificate()
        b&#39;-----BEGIN CERTIFICATE-----\\nMIIEfzCCA2egAwI...
        ```
        &#34;&#34;&#34;
        self.__validate_verification_tokens__()
        time.sleep(wait)
        deadline = datetime.datetime.now() + datetime.timedelta(seconds=timeout)

        # For each challenge, request an answer.
        for i, c in enumerate(self.__challenges__):
            self.__answers__.append(self.__client__.answer_challenge(c, self.__responses__[i]))

        # Request our final order and save the certificate if successful
        self.__final_order__ = self.__client__.poll_and_finalize(self.__order__, deadline=deadline)
        self.certificate = self.__final_order__.fullchain_pem.encode()
        return self.certificate

    def revoke_certificate(self, reason=0):
        &#34;&#34;&#34;
        Attempts to revoke the existing certificate from the issuing ACME server.\n
        - :param `reason` [`int`]: the numeric reason for revocation identifier.\n
        - :return [`none`]:\n
        - :raises `InvalidCertificate`: if this object does not contain a certificate.\n
        - :raises `acme.errors.ConflictError`: if the certificate is already revoked.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.revoke_certificate()
        ```
        &#34;&#34;&#34;
        self.__validate_certificate__()

        # Load the certificate crypto object and request revocation from the ACME server
        cert_obj = jose.ComparableX509(OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, self.certificate))
        self.__client__.revoke(cert_obj, reason)

    def new_account(self):
        &#34;&#34;&#34;
        Registers a new ACME account at the set ACME `directory` URL. By running this method, you are agreeing to the
        ACME servers terms of use.\n
        - :return [`none`]: the account and account_key properties will be updated with the new account registration.\n
        - :raises `InvalidDirectory`: if this object does not contain a valid ACME directory URL.\n
        - :raises `InvalidEmail`: if this object does not contain a valid email address to use during registration.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.new_account()
        ```
        &#34;&#34;&#34;
        self.__validate_directory__()
        self.__validate_email__()

        # Generate a new RSA2048 account key
        rsa_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=(default_backend()))
        self.account_key = jose.JWKRSA(key=rsa_key)

        # Initialize our ACME client object
        self.__net__ = client.ClientNetwork(self.account_key, user_agent=&#39;pyacmedns/1.0.0&#39;)
        self.__directory__ = messages.Directory.from_json(self.__net__.get(self.directory).json())
        self.__client__ = client.ClientV2(self.__directory__, net=self.__net__)

        # Complete registration
        registration = messages.NewRegistration.from_data(email=self.email, terms_of_service_agreed=True)
        self.account = self.__client__.new_account(registration)

    def deactivate_account(self, delete=True):
        &#34;&#34;&#34;
        Deactivates the current account registration. This action is irreversible.\n
        - :param `delete` [`bool`]: indicate whether any associated account file on the local system should also be
        deleted after deactivation.\n
        - :return [`none`]:\n
        - :raises `InvalidAccount`: when account registration has not been set.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.deactivate_account()
        ```
        &#34;&#34;&#34;
        self.__validate_registration__()

        # Tell the ACME server to deactivate this account
        self.__client__.deactivate_registration(self.account)

        # If this object contains a linked file path, and deletion is requested, delete the linked file
        if self.account_path and delete:
            pathlib.Path(self.account_path).unlink(missing_ok=True)

    def export_account(self, save_certificate=True, save_private_key=False):
        &#34;&#34;&#34;
        Exports the object as a JSON string. This is useful when using a framework like Django and need to store account
        data as a string in the database.\n
        - :param `save_certificate` [`bool`]: indicate whether the certificate should also be stored in the
        JSON string.\n
        - :param `save_private_key` [`bool`]: indicate whether the private key should also be stored in the
        JSON string.\n
        - :return [`str`]: the current object encoded as a JSON string.\n
        - :raises `InvalidAccount`: when account registration has not been set.\n
        - :raises `InvalidDomain`: when no valid domains are set.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.export_account(save_certificate=True, save_private_key=True)
        &#39;{&#34;account&#34;: {&#34;body&#34;: {&#34;key&#34;: {&#34;n&#34;: &#34;vtByzpW...&#34;}}}}&#39;
        ```
        &#34;&#34;&#34;
        self.__validate_registration__()
        self.__validate_domains__()

        # Format our object into a serializable format
        acct_data = {
            &#39;account&#39;: self.account.to_json(),
            &#39;account_key&#39;: self.account_key.json_dumps(),
            &#39;directory&#39;: self.directory,
            &#39;domains&#39;: self.domains,
            &#39;certificate&#39;: self.certificate.decode() if save_certificate else &#39;&#39;,
            &#39;private_key&#39;: self.private_key.decode() if save_private_key else &#39;&#39;
        }

        return json.dumps(acct_data)

    def export_account_to_file(self, path=&#39;.&#39;, name=&#39;account.json&#39;, save_certificate=True, save_private_key=False):
        &#34;&#34;&#34;
        Exports our object as a JSON file.\n
        - :param `path` [`str`]: the directory path to save the account file. Defaults to current working directory.\n
        - :param `name` [`str`]: the file name. Defaults to `account.json`.\n
        - :param `save_certificate` [`bool`]: indicate whether the certificate should also be stored in the JSON file.\n
        - :param `save_private_key` [`bool`]: indicate whether the private key should also be stored in the JSON file.\n
        - :return [`none`]: the file will be created at the specified path if an exception was not raised.\n
        - :raises `InvalidPath`: when the requested directory path to export the account to does not exist.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.export_account_to_file(
        ...     path=&#34;/tmp/&#34;,
        ...     name=&#34;my_acme_account.json&#34;,
        ...     save_certificate=True,
        ...     save_private_key=True
        ... )
        ```
        &#34;&#34;&#34;
        self.__validate_registration__()
        self.__validate_domains__()
        dir_path = pathlib.Path(path).absolute()

        # Ensure our path is an existing directory, throw an error otherwise
        if dir_path.is_dir():
            # Open the file and write our JSON content
            with open(str(dir_path.joinpath(name)), &#39;w&#39;) as (wa):
                wa.write(self.export_account(save_certificate, save_private_key))
                self.account_path = str(dir_path.joinpath(name))
        else:
            msg = &#34;Directory at &#39;{path}&#39; does not exist.&#34;.format(path=path)
            raise errors.InvalidPath(msg)

    @staticmethod
    def load_account(json_data):
        &#34;&#34;&#34;
        Loads an existing account from a JSON data string created by the `export_account()` method.\n
        - :param `json_data` [`str`]: the JSON account data string.\n
        - :return [`ACMEClient`]: the loaded ACMEClient object.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client = pyacmedns.ACMEClient.load_account(&#39;{&#34;account&#34;: {&#34;body&#34;: {&#34;key&#34;: {&#34;n&#34;: &#34;vtByzpW...&#34;}}}}&#39;)
        ```
        &#34;&#34;&#34;
        acct_data = json.loads(json_data)
        obj = ACMEClient()

        # Format the serialized data back into the object
        obj.directory = acct_data.get(&#39;directory&#39;, None)
        obj.domains = acct_data.get(&#39;domains&#39;, [])
        obj.certificate = acct_data.get(&#39;certificate&#39;, &#39;&#39;).encode()
        obj.private_key = acct_data.get(&#39;private_key&#39;, &#39;&#39;).encode()
        obj.email = acct_data[&#39;account&#39;][&#39;body&#39;][&#39;contact&#39;][0].replace(&#39;mailto:&#39;, &#39;&#39;)
        obj.account = messages.RegistrationResource.json_loads(json.dumps(acct_data[&#39;account&#39;]))
        obj.account_key = jose.JWKRSA.json_loads(acct_data[&#39;account_key&#39;])

        return obj

    @staticmethod
    def load_account_from_file(filepath):
        &#34;&#34;&#34;
        Loads an existing account from a JSON file created by the `export_account_to_file()` method.\n
        - :param `filepath` [`str`]: the file path to the account JSON file.\n
        - :return [`ACMEClient`]: the loaded ACMEClient object.\n
        - :raises `InvalidPath`: when the file path of the account JSON or key does not exist.\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client = pyacmedns.ACMEClient.load_account(&#39;/tmp/my_acme_account.json&#39;)
        ```
        &#34;&#34;&#34;
        filepath = pathlib.Path(filepath).absolute()

        # Ensure our file exists, throw an error otherwise
        if filepath.exists():
            # Open our file and read it&#39;s contents.
            with open(filepath, &#39;r&#39;) as (rj):
                json_data = rj.read()

            # Load contents into a new object.
            obj = ACMEClient.load_account(json_data)
            obj.account_path = filepath
        else:
            raise errors.InvalidPath(&#34;No JSON account file found at &#39;{path}&#39;&#34;.format(path=(str(filepath))))

        # Re-initialize the ACME client and registration
        obj.__net__ = client.ClientNetwork(obj.account_key, user_agent=&#39;pyacmedns/1.0.0&#39;)
        obj.__directory__ = messages.Directory.from_json(obj.__net__.get(obj.directory).json())
        obj.__client__ = client.ClientV2(obj.__directory__, net=obj.__net__)
        obj.account = obj.__client__.query_registration(obj.account)

        return obj

    def check_dns_propagation(self, timeout=300, interval=2, authoritative=False, round_robin=True, verbose=False):
        &#34;&#34;&#34;
        Check&#39;s each of our domain&#39;s TXT record until the value matches it&#39;s verification token or until the timeout is
        reached. This method should be executed before executing the `request_certificates()` method. This method can
        take several minutes to complete, ensure you adjust the timeout value accordingly.\n
        - :param `timeout` [`int`]: the amount of time (in seconds) to continue trying to verify the TXT records.\n
        - :param `interval` [`float`]: the amount of time (in seconds) between DNS requests per domain.\n
        - :param `authoritative` [`bool`]: identify and use the authoritative nameserver for each domain instead of the
        objects `nameservers` property values.\n
        - :param `round_robin` [`bool`]: rotate between each nameserver instead of the default failover method.\n
        - :param `verbose` [`bool`]: print DNS answers to the console.\n
        - :return [`bool`]: indicates whether or not all of the `domains` correctly return their verification token in
        their TXT record.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.nameservers = [&#34;8.8.8.8&#34;, &#34;1.1.1.1&#34;]
        &gt;&gt;&gt; client.check_dns_propagation(
        ...     timeout=180,
        ...     interval=5,
        ...     authoritative=False,
        ...     round_robin=True,
        ...     verbose=False
        ... )
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 8.8.8.8
        Token &#39;O32-fd_...&#39; for &#39;_acme-challenge.test2.example.com&#39; not found in [] via 8.8.8.8
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 1.1.1.1
        Token &#39;O32-fd_...&#39; for &#39;_acme-challenge.test2.example.com&#39; found in [&#39;O32-fd_...&#39;] via 1.1.1.1
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 8.8.8.8
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 1.1.1.1
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; found in [&#39;moY3Cd0...&#39;] via 8.8.8.8
        True
        ```
        &#34;&#34;&#34;
        self.__validate_verification_tokens__()
        verified = []
        resolvers = []
        timeout = datetime.datetime.now() + datetime.timedelta(seconds=timeout)

        # Create a DNS resolver object for each domain being verified
        for rdomain, rtoken in self.verification_tokens:
            r = tools.DNSQuery(
                rdomain,
                rtype=&#39;TXT&#39;,
                authoritative=authoritative,
                nameservers=self.nameservers,
                round_robin=round_robin
            )
            resolvers.append((rdomain, rtoken, r))

        # Loop until we have exceeded our timeout value
        while datetime.datetime.now() &lt; timeout:
            # Loop through each domain being verified
            for domain, token, resolver in resolvers:
                # Only try to verify the domain if it has not already been verified
                if domain not in verified:
                    resolver.resolve()
                    # Save this domain as verified if our token was found in the TXT record values
                    if token in resolver.values:
                        verified.append(domain)
                    # If verbose mode is enabled, print the results to the console
                    if verbose:
                        msg = &#34;Token &#39;{token}&#39; for &#39;{domain}&#39; {action} in {values} via {ns}&#34;.format(
                            token=token,
                            domain=domain,
                            action=(&#39;found&#39; if domain in verified else &#39;not found&#39;),
                            values=resolver.values,
                            ns=resolver.last_nameserver
                        )
                        print(msg)

            # If all our domains have been verified
            if len(verified) == len(self.verification_tokens):
                return True

            # Avoid flooding the DNS server(s)
            time.sleep(interval)

        return False

    def __verify_challenge__(self):
        &#34;&#34;&#34;
        Checks that the DNS-01 challenge is supported by the ACME server and initializes the challenge. This is an
        internal method and is not intended for use otherwise.
        :return: (list) a list of acme.challenges.ChallengeBody objects
        :raises: ChallengeUnavailable when the specified ACME server does not support the DNS-01 challenge
        &#34;&#34;&#34;
        self.__challenges__ = []
        authz_list = self.__order__.authorizations

        # Loop through each of our authorizations
        for authz in authz_list:
            # Loop through each authorization&#39;s available challenges
            for i in authz.body.challenges:
                # Add the DNS-01 challenge if it is found
                if isinstance(i.chall, challenges.DNS01):
                    self.__challenges__.append(i)

        # If no challenges were found, throw an error
        if not self.__challenges__:
            msg = &#34;ACME server at &#39;{directory}&#39; does not support DNS-01 challenge.&#34;
            raise errors.ChallengeUnavailable(msg.format(directory=(str(self.directory))))

        return self.__challenges__

    def __validate_registration__(self):
        &#34;&#34;&#34;
        Checks that our client is initialized with proper account registration.
        :return: (none)
        :raises: InvalidAccount when no account registration is configured for this object
        &#34;&#34;&#34;
        if type(self.__client__) != client.ClientV2:
            msg = &#39;No account registration found. You must register a new account or load an existing account first.&#39;
            raise errors.InvalidAccount(msg)

    def __validate_email__(self):
        &#34;&#34;&#34;
        Checks that our client is initialized with proper account email.
        :return: (none)
        :raises: InvalidEmail when no account email is configured for this object.
        &#34;&#34;&#34;
        if not self.email:
            msg = &#39;No account email found. You must set the email value first.&#39;
            raise errors.InvalidEmail(msg)

    def __validate_verification_tokens__(self):
        &#34;&#34;&#34;
        Checks that our client object has valid verification tokens.
        :return: (none)
        :raises: InvalidValidation when no verification tokens are issued for this object.
        &#34;&#34;&#34;
        if not self.__verification_tokens__:
            msg = &#39;No verification tokens found. You must run request_verification_tokens() first.&#39;
            raise errors.InvalidVerificationToken(msg)

    def __validate_domains__(self):
        &#34;&#34;&#34;
        Checks that our client is initialized with valid domain names.
        :return: (none)
        :raises: InvalidDomain when no domains are specified, domains is not list, or domain is not RFC2181 compliant.
        &#34;&#34;&#34;
        if not self.domains:
            msg = &#39;No domains found. You must set a domains value first.&#39;
            raise errors.InvalidDomain(msg)
        if type(self.domains) != list:
            msg = &#34;Domains must be rtype &#39;list&#39;.&#34;
            raise errors.InvalidDomain(msg)
        for domain in self.domains:
            if not validators.domain(domain):
                msg = &#34;Invalid domain name &#39;{domain}&#39;. Domain name must adhere to RFC2181.&#34;.format(domain=domain)
                raise errors.InvalidDomain(msg)

    def __validate_directory__(self):
        &#34;&#34;&#34;
        Checks that our client object has a valid ACME server directory URL.
        :return: (none)
        :raises: InvalidACMEDirectoryURL when no directory URL is set.
        &#34;&#34;&#34;
        if not self.directory:
            msg = &#39;No ACME server directory URL. You must set a directory value first.&#39;
            raise errors.InvalidACMEDirectoryURL(msg)

    def __validate_certificate__(self):
        &#34;&#34;&#34;
        Checks that our client object holds an issued certificate.
        :return: (none)
        :raises: InvalidCertificate when no certificate exists for this object.
        &#34;&#34;&#34;
        if not self.certificate:
            msg = &#39;No certificate found. You must load or request a certificate first.&#39;
            raise errors.InvalidCertificate(msg)

    def __validate_private_key__(self):
        &#34;&#34;&#34;
        Checks that our client is initialized with a valid private key.
        :return: (none)
        :raises: InvalidPrivateKey when no private exists for this object.
        &#34;&#34;&#34;
        if not self.private_key:
            msg = &#39;No private found. You must generate a private key first.&#39;
            raise errors.InvalidPrivateKey(msg)

    def __format_verification_tokens__(self):
        &#34;&#34;&#34;
        Formats the FQDNs the ACME server expects and their corresponding verification token to upload to DNS.
        :return: (list) a list of tuples. First value is the FQDN, second value is the verification token.
        &#34;&#34;&#34;
        self.__validate_domains__()
        self.__validate_verification_tokens__()
        groupings = []

        # Loop through each domain and group it with it&#39;s corresponding verification token
        for i, domain in enumerate(self.domains):
            groupings.append((self.DNS_LABEL + &#39;.&#39; + domain, self.__verification_tokens__[i]))

        self.verification_tokens = groupings
        return groupings</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyacmedns.errors" href="errors/index.html">pyacmedns.errors</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyacmedns.tools" href="tools/index.html">pyacmedns.tools</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyacmedns.ACMEClient"><code class="flex name class">
<span>class <span class="ident">ACMEClient</span></span>
<span>(</span><span>domains=None, email=None, directory=None, nameservers=None, new_account=False, generate_csr=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A basic ACME client object to interface with a CA using the ACME DNS-01 challenge.</p>
<ul>
<li>
<p>:var <code>certificate</code> [<code>bytes</code>]: the PEM formatted certificate. This value is populated after successfully running
the <code>request_certificate()</code> methood.</p>
</li>
<li>
<p>:var <code>private_key</code> [<code>bytes</code>]: the PEM formatted private key. This value is populated after successfully running
the <code>generate_private_key()</code> method.</p>
</li>
<li>
<p>:var <code>csr</code> [<code>bytes</code>]: the PEM formatted certificate signing request. This value is populated after successfully
running the <code>generate_csr()</code> method.</p>
</li>
<li>
<p>:param <code>domains</code> [<code>list</code>]: FQDNs to list in the certificate (SANS).</p>
</li>
<li>
<p>:param <code>email</code> [<code>str</code>]: a valid email address to register new ACME accounts with.</p>
</li>
<li>
<p>:param <code>directory</code> [<code>str</code>]: the ACME directory URL.</p>
</li>
<li>
<p>:param <code>nameservers</code> [<code>list</code>]: nameservers to use when querying DNS. Defaults to system nameservers.</p>
</li>
<li>
<p>:param <code>new_account</code> [<code>bool</code>]: automatically register a new account upon object creation. A <code>directory</code> and
<code>email</code> value will be required if True.</p>
</li>
<li>
<p>:param <code>generate_csr</code> [<code>bool</code>]: generate a new private key and CSR upon object creation. A <code>domains</code> value
will be required if True.</p>
</li>
</ul>
<h2 id="example">Example:</h2>
<pre><code class="language-python">&gt;&gt;&gt; import pyacmedns
&gt;&gt;&gt; client = pyacmedns.ACMEClient(
...     domains=[&quot;test1.example.com&quot;, &quot;test2.example.com&quot;],
...     email=&quot;example@example.com&quot;,
...     directory=&quot;https://acme-staging-v02.api.letsencrypt.org/directory&quot;,
...     nameservers=[&quot;8.8.8.8&quot;, &quot;1.1.1.1&quot;],
...     new_account=True,
...     generate_csr=True
... )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ACMEClient:
    &#34;&#34;&#34;
    A basic ACME client object to interface with a CA using the ACME DNS-01 challenge.\n
    - :var `certificate` [`bytes`]: the PEM formatted certificate. This value is populated after successfully running
    the `request_certificate()` methood.\n
    - :var `private_key` [`bytes`]: the PEM formatted private key. This value is populated after successfully running
    the `generate_private_key()` method.\n
    - :var `csr` [`bytes`]: the PEM formatted certificate signing request. This value is populated after successfully
    running the `generate_csr()` method.\n
    &#34;&#34;&#34;

    def __init__(
            self, domains=None, email=None, directory=None, nameservers=None, new_account=False, generate_csr=False
    ):
        &#34;&#34;&#34;
        - :param `domains` [`list`]: FQDNs to list in the certificate (SANS).\n
        - :param `email` [`str`]: a valid email address to register new ACME accounts with.\n
        - :param `directory` [`str`]: the ACME directory URL.\n
        - :param `nameservers` [`list`]: nameservers to use when querying DNS. Defaults to system nameservers.\n
        - :param `new_account` [`bool`]: automatically register a new account upon object creation. A `directory` and
        `email` value will be required if True.\n
        - :param `generate_csr` [`bool`]: generate a new private key and CSR upon object creation. A `domains` value
        will be required if True.\n\n

        ## Example:\n
        ```python
        &gt;&gt;&gt; import pyacmedns
        &gt;&gt;&gt; client = pyacmedns.ACMEClient(
        ...     domains=[&#34;test1.example.com&#34;, &#34;test2.example.com&#34;],
        ...     email=&#34;example@example.com&#34;,
        ...     directory=&#34;https://acme-staging-v02.api.letsencrypt.org/directory&#34;,
        ...     nameservers=[&#34;8.8.8.8&#34;, &#34;1.1.1.1&#34;],
        ...     new_account=True,
        ...     generate_csr=True
        ... )
        ```

        &#34;&#34;&#34;
        self.DNS_LABEL = &#39;_acme-challenge&#39;
        self.domains = domains if domains else []
        self.email = email
        self.directory = directory
        self.certificate = &#39;&#39;.encode()
        self.private_key = &#39;&#39;.encode()
        self.csr = &#39;&#39;.encode()
        self.verification_tokens = []
        self.account_key = None
        self.account = None
        self.account_path = None
        self.nameservers = nameservers
        self.__private_key__ = None
        self.__client__ = None
        self.__net__ = None
        self.__directory__ = None
        self.__order__ = None
        self.__final_order__ = None
        self.__verification_tokens__ = []
        self.__responses__ = []
        self.__challenges__ = []
        self.__answers__ = []

        # Automatically create a new account if requested
        if new_account:
            self.new_account()
        # Automatically create a new private key and CSR
        if generate_csr:
            self.generate_private_key_and_csr()

    def generate_csr(self):
        &#34;&#34;&#34;
        Generates a new CSR using the object&#39;s `domains` and `private_key` values.\n
        - :return [`bytes`]: the encoded CSR PEM data string. This method will update the `csr` property of the object
        with the same value.\n
        - :raises `InvalidDomain`: when no valid `domains` are set.\n
        - :raises `InvalidPrivateKey`: when no `private_key` exists for this object.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.generate_csr()
        b&#39;-----BEGIN CERTIFICATE REQUEST-----\\nMIHxMIGZAgECMAAwWTATBgckjkn...&#39;
        ```
        &#34;&#34;&#34;
        self.__validate_domains__()
        self.__validate_private_key__()
        self.csr = crypto_util.make_csr(self.private_key, self.domains)
        return self.csr

    def generate_private_key(self, key_type=&#39;ec256&#39;):
        &#34;&#34;&#34;
        Generates a new RSA or EC private key.\n
        - :param `key_type` [`str`]: the requested `private_key` type. Options are: [`ec256`, `ec384`, `rsa2048`,
        `rsa4098`]\n
        - :return [`bytes`]: the encoded private key PEM data string. This method will update the `private_key` property
         of the object with the same value.\n
        - :raises `InvalidKeyType`: when an unknown/unsupported `key_type` is requested\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.generate_private_key(key_type=&#34;ec384&#34;)
        b&#39;-----BEGIN EC PRIVATE KEY-----\\nMIGkAgEBBDAZRFNLcQdVJmLh42p8F4D92...&#39;
        ```
        &#34;&#34;&#34;
        # Generate a EC256 private key
        if key_type == &#39;ec256&#39;:
            key = ec.generate_private_key(ec.SECP256R1(), default_backend())
            self.private_key = key.private_bytes(
                encoding=Encoding.PEM,
                format=PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=NoEncryption())
        # Generate a EC384 private key
        elif key_type == &#39;ec384&#39;:
            key = ec.generate_private_key(ec.SECP384R1(), default_backend())
            self.private_key = key.private_bytes(
                encoding=Encoding.PEM,
                format=PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=NoEncryption()
            )
        # Generate a RSA2048 private key
        elif key_type == &#39;rsa2048&#39;:
            key = OpenSSL.crypto.PKey()
            key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048)
            self.private_key = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
        # Generate a RSA4098 private key
        elif key_type == &#39;rsa4098&#39;:
            key = OpenSSL.crypto.PKey()
            key.generate_key(OpenSSL.crypto.TYPE_RSA, 4096)
            self.private_key = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
        # Otherwise, the requested key type is not supported. Throw an error
        else:
            options = [&#39;ec256&#39;, &#39;ec384&#39;, &#39;rsa2048&#39;, &#39;rsa4098&#39;]
            msg = &#34;Invalid private key rtype &#39;{key_type}&#39;. Options {options}&#34;.format(key_type=key_type, options=options)
            raise errors.InvalidKeyType(msg)
        return self.private_key

    def generate_private_key_and_csr(self, key_type=&#39;ec256&#39;):
        &#34;&#34;&#34;
        Generates a new private key and CSR.\n
        - :param `key_type` [`str`]: the requested `private_key` type. Options are: [`ec256`, `ec384`, `rsa2048`,
        `rsa4098`]\n
        - :return [`tuple`]: first value contains the key, the second value contains the CSR. This method will update
        the `private_key` and `csr` properties of this object with the same values.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.generate_private_key_and_csr(key_type=&#34;rsa2048&#34;)
        (b&#39;-----BEGIN PRIVATE KEY-----\\nMIIEvAIBA...&#39;, b&#39;-----BEGIN CERTIFICATE REQUEST-----\\nMIHxM...&#39;)
        ```
        &#34;&#34;&#34;
        self.generate_private_key(key_type=key_type)
        self.generate_csr()
        return self.private_key, self.csr

    def request_verification_tokens(self):
        &#34;&#34;&#34;
        Requests verification tokens from the ACME server for each `domains` value. These tokens must be uploaded as
        a DNS TXT record for each corresponding domain to complete verification.\n
        - :return [`list`]: a list of tuples containing the challenge FQDN and it&#39;s corresponding verification token.\n
        - :raises `InvalidAccount`: when account registration has not been set.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.request_verification_tokens()
        [
            (&#39;_acme-challenge.test1.example.com&#39;, &#39;moY32lkdsZ3VWHM1mdM...&#39;),
            (&#39;_acme-challenge.test2.example.com&#39;, &#39;asldfkjslweietj23_b...&#39;)
        ]
        ```
        &#34;&#34;&#34;
        self.__validate_registration__()
        self.__responses__ = []
        self.__verification_tokens__ = []
        self.__order__ = self.__client__.new_order(self.csr)
        self.__challenges__ = self.__verify_challenge__()

        # Loop through each of our challenges and extract the response and verification token from each
        for i, c in enumerate(self.__challenges__):
            response, validation = c.response_and_validation(self.__client__.net.key)
            self.__responses__.append(response)
            self.__verification_tokens__.append(validation)

        return self.__format_verification_tokens__()

    def request_certificate(self, wait=0, timeout=90):
        &#34;&#34;&#34;
        Requests a final verification answer from the ACME server and requests the certificate if verification was
        successful. If you request the certificate before DNS has propagated and verification fails, you must start
        the verification process over entirely by requesting new verification tokens.\n
        - :param `wait` [`int`]: amount of time (in seconds) to wait before requesting a challenge answer from the
        server. This is only necessary if you are not using the `check_dns_propagation()` method to verify the DNS
        records exist and would rather wait a specific amount of time.\n
        - :return [`bytes`]: the PEM encoded certificate. This method will update the `certificate` and `csr` property
        of this object with the same value.\n
        - :raises `InvalidAccount`:  when account registration has not been set.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.request_certificate()
        b&#39;-----BEGIN CERTIFICATE-----\\nMIIEfzCCA2egAwI...
        ```
        &#34;&#34;&#34;
        self.__validate_verification_tokens__()
        time.sleep(wait)
        deadline = datetime.datetime.now() + datetime.timedelta(seconds=timeout)

        # For each challenge, request an answer.
        for i, c in enumerate(self.__challenges__):
            self.__answers__.append(self.__client__.answer_challenge(c, self.__responses__[i]))

        # Request our final order and save the certificate if successful
        self.__final_order__ = self.__client__.poll_and_finalize(self.__order__, deadline=deadline)
        self.certificate = self.__final_order__.fullchain_pem.encode()
        return self.certificate

    def revoke_certificate(self, reason=0):
        &#34;&#34;&#34;
        Attempts to revoke the existing certificate from the issuing ACME server.\n
        - :param `reason` [`int`]: the numeric reason for revocation identifier.\n
        - :return [`none`]:\n
        - :raises `InvalidCertificate`: if this object does not contain a certificate.\n
        - :raises `acme.errors.ConflictError`: if the certificate is already revoked.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.revoke_certificate()
        ```
        &#34;&#34;&#34;
        self.__validate_certificate__()

        # Load the certificate crypto object and request revocation from the ACME server
        cert_obj = jose.ComparableX509(OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, self.certificate))
        self.__client__.revoke(cert_obj, reason)

    def new_account(self):
        &#34;&#34;&#34;
        Registers a new ACME account at the set ACME `directory` URL. By running this method, you are agreeing to the
        ACME servers terms of use.\n
        - :return [`none`]: the account and account_key properties will be updated with the new account registration.\n
        - :raises `InvalidDirectory`: if this object does not contain a valid ACME directory URL.\n
        - :raises `InvalidEmail`: if this object does not contain a valid email address to use during registration.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.new_account()
        ```
        &#34;&#34;&#34;
        self.__validate_directory__()
        self.__validate_email__()

        # Generate a new RSA2048 account key
        rsa_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=(default_backend()))
        self.account_key = jose.JWKRSA(key=rsa_key)

        # Initialize our ACME client object
        self.__net__ = client.ClientNetwork(self.account_key, user_agent=&#39;pyacmedns/1.0.0&#39;)
        self.__directory__ = messages.Directory.from_json(self.__net__.get(self.directory).json())
        self.__client__ = client.ClientV2(self.__directory__, net=self.__net__)

        # Complete registration
        registration = messages.NewRegistration.from_data(email=self.email, terms_of_service_agreed=True)
        self.account = self.__client__.new_account(registration)

    def deactivate_account(self, delete=True):
        &#34;&#34;&#34;
        Deactivates the current account registration. This action is irreversible.\n
        - :param `delete` [`bool`]: indicate whether any associated account file on the local system should also be
        deleted after deactivation.\n
        - :return [`none`]:\n
        - :raises `InvalidAccount`: when account registration has not been set.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.deactivate_account()
        ```
        &#34;&#34;&#34;
        self.__validate_registration__()

        # Tell the ACME server to deactivate this account
        self.__client__.deactivate_registration(self.account)

        # If this object contains a linked file path, and deletion is requested, delete the linked file
        if self.account_path and delete:
            pathlib.Path(self.account_path).unlink(missing_ok=True)

    def export_account(self, save_certificate=True, save_private_key=False):
        &#34;&#34;&#34;
        Exports the object as a JSON string. This is useful when using a framework like Django and need to store account
        data as a string in the database.\n
        - :param `save_certificate` [`bool`]: indicate whether the certificate should also be stored in the
        JSON string.\n
        - :param `save_private_key` [`bool`]: indicate whether the private key should also be stored in the
        JSON string.\n
        - :return [`str`]: the current object encoded as a JSON string.\n
        - :raises `InvalidAccount`: when account registration has not been set.\n
        - :raises `InvalidDomain`: when no valid domains are set.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.export_account(save_certificate=True, save_private_key=True)
        &#39;{&#34;account&#34;: {&#34;body&#34;: {&#34;key&#34;: {&#34;n&#34;: &#34;vtByzpW...&#34;}}}}&#39;
        ```
        &#34;&#34;&#34;
        self.__validate_registration__()
        self.__validate_domains__()

        # Format our object into a serializable format
        acct_data = {
            &#39;account&#39;: self.account.to_json(),
            &#39;account_key&#39;: self.account_key.json_dumps(),
            &#39;directory&#39;: self.directory,
            &#39;domains&#39;: self.domains,
            &#39;certificate&#39;: self.certificate.decode() if save_certificate else &#39;&#39;,
            &#39;private_key&#39;: self.private_key.decode() if save_private_key else &#39;&#39;
        }

        return json.dumps(acct_data)

    def export_account_to_file(self, path=&#39;.&#39;, name=&#39;account.json&#39;, save_certificate=True, save_private_key=False):
        &#34;&#34;&#34;
        Exports our object as a JSON file.\n
        - :param `path` [`str`]: the directory path to save the account file. Defaults to current working directory.\n
        - :param `name` [`str`]: the file name. Defaults to `account.json`.\n
        - :param `save_certificate` [`bool`]: indicate whether the certificate should also be stored in the JSON file.\n
        - :param `save_private_key` [`bool`]: indicate whether the private key should also be stored in the JSON file.\n
        - :return [`none`]: the file will be created at the specified path if an exception was not raised.\n
        - :raises `InvalidPath`: when the requested directory path to export the account to does not exist.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.export_account_to_file(
        ...     path=&#34;/tmp/&#34;,
        ...     name=&#34;my_acme_account.json&#34;,
        ...     save_certificate=True,
        ...     save_private_key=True
        ... )
        ```
        &#34;&#34;&#34;
        self.__validate_registration__()
        self.__validate_domains__()
        dir_path = pathlib.Path(path).absolute()

        # Ensure our path is an existing directory, throw an error otherwise
        if dir_path.is_dir():
            # Open the file and write our JSON content
            with open(str(dir_path.joinpath(name)), &#39;w&#39;) as (wa):
                wa.write(self.export_account(save_certificate, save_private_key))
                self.account_path = str(dir_path.joinpath(name))
        else:
            msg = &#34;Directory at &#39;{path}&#39; does not exist.&#34;.format(path=path)
            raise errors.InvalidPath(msg)

    @staticmethod
    def load_account(json_data):
        &#34;&#34;&#34;
        Loads an existing account from a JSON data string created by the `export_account()` method.\n
        - :param `json_data` [`str`]: the JSON account data string.\n
        - :return [`ACMEClient`]: the loaded ACMEClient object.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client = pyacmedns.ACMEClient.load_account(&#39;{&#34;account&#34;: {&#34;body&#34;: {&#34;key&#34;: {&#34;n&#34;: &#34;vtByzpW...&#34;}}}}&#39;)
        ```
        &#34;&#34;&#34;
        acct_data = json.loads(json_data)
        obj = ACMEClient()

        # Format the serialized data back into the object
        obj.directory = acct_data.get(&#39;directory&#39;, None)
        obj.domains = acct_data.get(&#39;domains&#39;, [])
        obj.certificate = acct_data.get(&#39;certificate&#39;, &#39;&#39;).encode()
        obj.private_key = acct_data.get(&#39;private_key&#39;, &#39;&#39;).encode()
        obj.email = acct_data[&#39;account&#39;][&#39;body&#39;][&#39;contact&#39;][0].replace(&#39;mailto:&#39;, &#39;&#39;)
        obj.account = messages.RegistrationResource.json_loads(json.dumps(acct_data[&#39;account&#39;]))
        obj.account_key = jose.JWKRSA.json_loads(acct_data[&#39;account_key&#39;])

        return obj

    @staticmethod
    def load_account_from_file(filepath):
        &#34;&#34;&#34;
        Loads an existing account from a JSON file created by the `export_account_to_file()` method.\n
        - :param `filepath` [`str`]: the file path to the account JSON file.\n
        - :return [`ACMEClient`]: the loaded ACMEClient object.\n
        - :raises `InvalidPath`: when the file path of the account JSON or key does not exist.\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client = pyacmedns.ACMEClient.load_account(&#39;/tmp/my_acme_account.json&#39;)
        ```
        &#34;&#34;&#34;
        filepath = pathlib.Path(filepath).absolute()

        # Ensure our file exists, throw an error otherwise
        if filepath.exists():
            # Open our file and read it&#39;s contents.
            with open(filepath, &#39;r&#39;) as (rj):
                json_data = rj.read()

            # Load contents into a new object.
            obj = ACMEClient.load_account(json_data)
            obj.account_path = filepath
        else:
            raise errors.InvalidPath(&#34;No JSON account file found at &#39;{path}&#39;&#34;.format(path=(str(filepath))))

        # Re-initialize the ACME client and registration
        obj.__net__ = client.ClientNetwork(obj.account_key, user_agent=&#39;pyacmedns/1.0.0&#39;)
        obj.__directory__ = messages.Directory.from_json(obj.__net__.get(obj.directory).json())
        obj.__client__ = client.ClientV2(obj.__directory__, net=obj.__net__)
        obj.account = obj.__client__.query_registration(obj.account)

        return obj

    def check_dns_propagation(self, timeout=300, interval=2, authoritative=False, round_robin=True, verbose=False):
        &#34;&#34;&#34;
        Check&#39;s each of our domain&#39;s TXT record until the value matches it&#39;s verification token or until the timeout is
        reached. This method should be executed before executing the `request_certificates()` method. This method can
        take several minutes to complete, ensure you adjust the timeout value accordingly.\n
        - :param `timeout` [`int`]: the amount of time (in seconds) to continue trying to verify the TXT records.\n
        - :param `interval` [`float`]: the amount of time (in seconds) between DNS requests per domain.\n
        - :param `authoritative` [`bool`]: identify and use the authoritative nameserver for each domain instead of the
        objects `nameservers` property values.\n
        - :param `round_robin` [`bool`]: rotate between each nameserver instead of the default failover method.\n
        - :param `verbose` [`bool`]: print DNS answers to the console.\n
        - :return [`bool`]: indicates whether or not all of the `domains` correctly return their verification token in
        their TXT record.\n\n

        ## Example\n
        ```python
        &gt;&gt;&gt; client.nameservers = [&#34;8.8.8.8&#34;, &#34;1.1.1.1&#34;]
        &gt;&gt;&gt; client.check_dns_propagation(
        ...     timeout=180,
        ...     interval=5,
        ...     authoritative=False,
        ...     round_robin=True,
        ...     verbose=False
        ... )
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 8.8.8.8
        Token &#39;O32-fd_...&#39; for &#39;_acme-challenge.test2.example.com&#39; not found in [] via 8.8.8.8
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 1.1.1.1
        Token &#39;O32-fd_...&#39; for &#39;_acme-challenge.test2.example.com&#39; found in [&#39;O32-fd_...&#39;] via 1.1.1.1
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 8.8.8.8
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 1.1.1.1
        Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; found in [&#39;moY3Cd0...&#39;] via 8.8.8.8
        True
        ```
        &#34;&#34;&#34;
        self.__validate_verification_tokens__()
        verified = []
        resolvers = []
        timeout = datetime.datetime.now() + datetime.timedelta(seconds=timeout)

        # Create a DNS resolver object for each domain being verified
        for rdomain, rtoken in self.verification_tokens:
            r = tools.DNSQuery(
                rdomain,
                rtype=&#39;TXT&#39;,
                authoritative=authoritative,
                nameservers=self.nameservers,
                round_robin=round_robin
            )
            resolvers.append((rdomain, rtoken, r))

        # Loop until we have exceeded our timeout value
        while datetime.datetime.now() &lt; timeout:
            # Loop through each domain being verified
            for domain, token, resolver in resolvers:
                # Only try to verify the domain if it has not already been verified
                if domain not in verified:
                    resolver.resolve()
                    # Save this domain as verified if our token was found in the TXT record values
                    if token in resolver.values:
                        verified.append(domain)
                    # If verbose mode is enabled, print the results to the console
                    if verbose:
                        msg = &#34;Token &#39;{token}&#39; for &#39;{domain}&#39; {action} in {values} via {ns}&#34;.format(
                            token=token,
                            domain=domain,
                            action=(&#39;found&#39; if domain in verified else &#39;not found&#39;),
                            values=resolver.values,
                            ns=resolver.last_nameserver
                        )
                        print(msg)

            # If all our domains have been verified
            if len(verified) == len(self.verification_tokens):
                return True

            # Avoid flooding the DNS server(s)
            time.sleep(interval)

        return False

    def __verify_challenge__(self):
        &#34;&#34;&#34;
        Checks that the DNS-01 challenge is supported by the ACME server and initializes the challenge. This is an
        internal method and is not intended for use otherwise.
        :return: (list) a list of acme.challenges.ChallengeBody objects
        :raises: ChallengeUnavailable when the specified ACME server does not support the DNS-01 challenge
        &#34;&#34;&#34;
        self.__challenges__ = []
        authz_list = self.__order__.authorizations

        # Loop through each of our authorizations
        for authz in authz_list:
            # Loop through each authorization&#39;s available challenges
            for i in authz.body.challenges:
                # Add the DNS-01 challenge if it is found
                if isinstance(i.chall, challenges.DNS01):
                    self.__challenges__.append(i)

        # If no challenges were found, throw an error
        if not self.__challenges__:
            msg = &#34;ACME server at &#39;{directory}&#39; does not support DNS-01 challenge.&#34;
            raise errors.ChallengeUnavailable(msg.format(directory=(str(self.directory))))

        return self.__challenges__

    def __validate_registration__(self):
        &#34;&#34;&#34;
        Checks that our client is initialized with proper account registration.
        :return: (none)
        :raises: InvalidAccount when no account registration is configured for this object
        &#34;&#34;&#34;
        if type(self.__client__) != client.ClientV2:
            msg = &#39;No account registration found. You must register a new account or load an existing account first.&#39;
            raise errors.InvalidAccount(msg)

    def __validate_email__(self):
        &#34;&#34;&#34;
        Checks that our client is initialized with proper account email.
        :return: (none)
        :raises: InvalidEmail when no account email is configured for this object.
        &#34;&#34;&#34;
        if not self.email:
            msg = &#39;No account email found. You must set the email value first.&#39;
            raise errors.InvalidEmail(msg)

    def __validate_verification_tokens__(self):
        &#34;&#34;&#34;
        Checks that our client object has valid verification tokens.
        :return: (none)
        :raises: InvalidValidation when no verification tokens are issued for this object.
        &#34;&#34;&#34;
        if not self.__verification_tokens__:
            msg = &#39;No verification tokens found. You must run request_verification_tokens() first.&#39;
            raise errors.InvalidVerificationToken(msg)

    def __validate_domains__(self):
        &#34;&#34;&#34;
        Checks that our client is initialized with valid domain names.
        :return: (none)
        :raises: InvalidDomain when no domains are specified, domains is not list, or domain is not RFC2181 compliant.
        &#34;&#34;&#34;
        if not self.domains:
            msg = &#39;No domains found. You must set a domains value first.&#39;
            raise errors.InvalidDomain(msg)
        if type(self.domains) != list:
            msg = &#34;Domains must be rtype &#39;list&#39;.&#34;
            raise errors.InvalidDomain(msg)
        for domain in self.domains:
            if not validators.domain(domain):
                msg = &#34;Invalid domain name &#39;{domain}&#39;. Domain name must adhere to RFC2181.&#34;.format(domain=domain)
                raise errors.InvalidDomain(msg)

    def __validate_directory__(self):
        &#34;&#34;&#34;
        Checks that our client object has a valid ACME server directory URL.
        :return: (none)
        :raises: InvalidACMEDirectoryURL when no directory URL is set.
        &#34;&#34;&#34;
        if not self.directory:
            msg = &#39;No ACME server directory URL. You must set a directory value first.&#39;
            raise errors.InvalidACMEDirectoryURL(msg)

    def __validate_certificate__(self):
        &#34;&#34;&#34;
        Checks that our client object holds an issued certificate.
        :return: (none)
        :raises: InvalidCertificate when no certificate exists for this object.
        &#34;&#34;&#34;
        if not self.certificate:
            msg = &#39;No certificate found. You must load or request a certificate first.&#39;
            raise errors.InvalidCertificate(msg)

    def __validate_private_key__(self):
        &#34;&#34;&#34;
        Checks that our client is initialized with a valid private key.
        :return: (none)
        :raises: InvalidPrivateKey when no private exists for this object.
        &#34;&#34;&#34;
        if not self.private_key:
            msg = &#39;No private found. You must generate a private key first.&#39;
            raise errors.InvalidPrivateKey(msg)

    def __format_verification_tokens__(self):
        &#34;&#34;&#34;
        Formats the FQDNs the ACME server expects and their corresponding verification token to upload to DNS.
        :return: (list) a list of tuples. First value is the FQDN, second value is the verification token.
        &#34;&#34;&#34;
        self.__validate_domains__()
        self.__validate_verification_tokens__()
        groupings = []

        # Loop through each domain and group it with it&#39;s corresponding verification token
        for i, domain in enumerate(self.domains):
            groupings.append((self.DNS_LABEL + &#39;.&#39; + domain, self.__verification_tokens__[i]))

        self.verification_tokens = groupings
        return groupings</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyacmedns.ACMEClient.load_account"><code class="name flex">
<span>def <span class="ident">load_account</span></span>(<span>json_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads an existing account from a JSON data string created by the <code>export_account()</code> method.</p>
<ul>
<li>
<p>:param <code>json_data</code> [<code>str</code>]: the JSON account data string.</p>
</li>
<li>
<p>:return [<code>ACMEClient</code>]: the loaded ACMEClient object.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client = pyacmedns.ACMEClient.load_account('{&quot;account&quot;: {&quot;body&quot;: {&quot;key&quot;: {&quot;n&quot;: &quot;vtByzpW...&quot;}}}}')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_account(json_data):
    &#34;&#34;&#34;
    Loads an existing account from a JSON data string created by the `export_account()` method.\n
    - :param `json_data` [`str`]: the JSON account data string.\n
    - :return [`ACMEClient`]: the loaded ACMEClient object.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client = pyacmedns.ACMEClient.load_account(&#39;{&#34;account&#34;: {&#34;body&#34;: {&#34;key&#34;: {&#34;n&#34;: &#34;vtByzpW...&#34;}}}}&#39;)
    ```
    &#34;&#34;&#34;
    acct_data = json.loads(json_data)
    obj = ACMEClient()

    # Format the serialized data back into the object
    obj.directory = acct_data.get(&#39;directory&#39;, None)
    obj.domains = acct_data.get(&#39;domains&#39;, [])
    obj.certificate = acct_data.get(&#39;certificate&#39;, &#39;&#39;).encode()
    obj.private_key = acct_data.get(&#39;private_key&#39;, &#39;&#39;).encode()
    obj.email = acct_data[&#39;account&#39;][&#39;body&#39;][&#39;contact&#39;][0].replace(&#39;mailto:&#39;, &#39;&#39;)
    obj.account = messages.RegistrationResource.json_loads(json.dumps(acct_data[&#39;account&#39;]))
    obj.account_key = jose.JWKRSA.json_loads(acct_data[&#39;account_key&#39;])

    return obj</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.load_account_from_file"><code class="name flex">
<span>def <span class="ident">load_account_from_file</span></span>(<span>filepath)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads an existing account from a JSON file created by the <code>export_account_to_file()</code> method.</p>
<ul>
<li>
<p>:param <code>filepath</code> [<code>str</code>]: the file path to the account JSON file.</p>
</li>
<li>
<p>:return [<code>ACMEClient</code>]: the loaded ACMEClient object.</p>
</li>
<li>
<p>:raises <code>InvalidPath</code>: when the file path of the account JSON or key does not exist.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client = pyacmedns.ACMEClient.load_account('/tmp/my_acme_account.json')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_account_from_file(filepath):
    &#34;&#34;&#34;
    Loads an existing account from a JSON file created by the `export_account_to_file()` method.\n
    - :param `filepath` [`str`]: the file path to the account JSON file.\n
    - :return [`ACMEClient`]: the loaded ACMEClient object.\n
    - :raises `InvalidPath`: when the file path of the account JSON or key does not exist.\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client = pyacmedns.ACMEClient.load_account(&#39;/tmp/my_acme_account.json&#39;)
    ```
    &#34;&#34;&#34;
    filepath = pathlib.Path(filepath).absolute()

    # Ensure our file exists, throw an error otherwise
    if filepath.exists():
        # Open our file and read it&#39;s contents.
        with open(filepath, &#39;r&#39;) as (rj):
            json_data = rj.read()

        # Load contents into a new object.
        obj = ACMEClient.load_account(json_data)
        obj.account_path = filepath
    else:
        raise errors.InvalidPath(&#34;No JSON account file found at &#39;{path}&#39;&#34;.format(path=(str(filepath))))

    # Re-initialize the ACME client and registration
    obj.__net__ = client.ClientNetwork(obj.account_key, user_agent=&#39;pyacmedns/1.0.0&#39;)
    obj.__directory__ = messages.Directory.from_json(obj.__net__.get(obj.directory).json())
    obj.__client__ = client.ClientV2(obj.__directory__, net=obj.__net__)
    obj.account = obj.__client__.query_registration(obj.account)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyacmedns.ACMEClient.check_dns_propagation"><code class="name flex">
<span>def <span class="ident">check_dns_propagation</span></span>(<span>self, timeout=300, interval=2, authoritative=False, round_robin=True, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Check's each of our domain's TXT record until the value matches it's verification token or until the timeout is
reached. This method should be executed before executing the <code>request_certificates()</code> method. This method can
take several minutes to complete, ensure you adjust the timeout value accordingly.</p>
<ul>
<li>
<p>:param <code>timeout</code> [<code>int</code>]: the amount of time (in seconds) to continue trying to verify the TXT records.</p>
</li>
<li>
<p>:param <code>interval</code> [<code>float</code>]: the amount of time (in seconds) between DNS requests per domain.</p>
</li>
<li>
<p>:param <code>authoritative</code> [<code>bool</code>]: identify and use the authoritative nameserver for each domain instead of the
objects <code>nameservers</code> property values.</p>
</li>
<li>
<p>:param <code>round_robin</code> [<code>bool</code>]: rotate between each nameserver instead of the default failover method.</p>
</li>
<li>
<p>:param <code>verbose</code> [<code>bool</code>]: print DNS answers to the console.</p>
</li>
<li>
<p>:return [<code>bool</code>]: indicates whether or not all of the <code>domains</code> correctly return their verification token in
their TXT record.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.nameservers = [&quot;8.8.8.8&quot;, &quot;1.1.1.1&quot;]
&gt;&gt;&gt; client.check_dns_propagation(
...     timeout=180,
...     interval=5,
...     authoritative=False,
...     round_robin=True,
...     verbose=False
... )
Token 'moY3Cd0...' for '_acme-challenge.test1.example.com' not found in [] via 8.8.8.8
Token 'O32-fd_...' for '_acme-challenge.test2.example.com' not found in [] via 8.8.8.8
Token 'moY3Cd0...' for '_acme-challenge.test1.example.com' not found in [] via 1.1.1.1
Token 'O32-fd_...' for '_acme-challenge.test2.example.com' found in ['O32-fd_...'] via 1.1.1.1
Token 'moY3Cd0...' for '_acme-challenge.test1.example.com' not found in [] via 8.8.8.8
Token 'moY3Cd0...' for '_acme-challenge.test1.example.com' not found in [] via 1.1.1.1
Token 'moY3Cd0...' for '_acme-challenge.test1.example.com' found in ['moY3Cd0...'] via 8.8.8.8
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_dns_propagation(self, timeout=300, interval=2, authoritative=False, round_robin=True, verbose=False):
    &#34;&#34;&#34;
    Check&#39;s each of our domain&#39;s TXT record until the value matches it&#39;s verification token or until the timeout is
    reached. This method should be executed before executing the `request_certificates()` method. This method can
    take several minutes to complete, ensure you adjust the timeout value accordingly.\n
    - :param `timeout` [`int`]: the amount of time (in seconds) to continue trying to verify the TXT records.\n
    - :param `interval` [`float`]: the amount of time (in seconds) between DNS requests per domain.\n
    - :param `authoritative` [`bool`]: identify and use the authoritative nameserver for each domain instead of the
    objects `nameservers` property values.\n
    - :param `round_robin` [`bool`]: rotate between each nameserver instead of the default failover method.\n
    - :param `verbose` [`bool`]: print DNS answers to the console.\n
    - :return [`bool`]: indicates whether or not all of the `domains` correctly return their verification token in
    their TXT record.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.nameservers = [&#34;8.8.8.8&#34;, &#34;1.1.1.1&#34;]
    &gt;&gt;&gt; client.check_dns_propagation(
    ...     timeout=180,
    ...     interval=5,
    ...     authoritative=False,
    ...     round_robin=True,
    ...     verbose=False
    ... )
    Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 8.8.8.8
    Token &#39;O32-fd_...&#39; for &#39;_acme-challenge.test2.example.com&#39; not found in [] via 8.8.8.8
    Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 1.1.1.1
    Token &#39;O32-fd_...&#39; for &#39;_acme-challenge.test2.example.com&#39; found in [&#39;O32-fd_...&#39;] via 1.1.1.1
    Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 8.8.8.8
    Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; not found in [] via 1.1.1.1
    Token &#39;moY3Cd0...&#39; for &#39;_acme-challenge.test1.example.com&#39; found in [&#39;moY3Cd0...&#39;] via 8.8.8.8
    True
    ```
    &#34;&#34;&#34;
    self.__validate_verification_tokens__()
    verified = []
    resolvers = []
    timeout = datetime.datetime.now() + datetime.timedelta(seconds=timeout)

    # Create a DNS resolver object for each domain being verified
    for rdomain, rtoken in self.verification_tokens:
        r = tools.DNSQuery(
            rdomain,
            rtype=&#39;TXT&#39;,
            authoritative=authoritative,
            nameservers=self.nameservers,
            round_robin=round_robin
        )
        resolvers.append((rdomain, rtoken, r))

    # Loop until we have exceeded our timeout value
    while datetime.datetime.now() &lt; timeout:
        # Loop through each domain being verified
        for domain, token, resolver in resolvers:
            # Only try to verify the domain if it has not already been verified
            if domain not in verified:
                resolver.resolve()
                # Save this domain as verified if our token was found in the TXT record values
                if token in resolver.values:
                    verified.append(domain)
                # If verbose mode is enabled, print the results to the console
                if verbose:
                    msg = &#34;Token &#39;{token}&#39; for &#39;{domain}&#39; {action} in {values} via {ns}&#34;.format(
                        token=token,
                        domain=domain,
                        action=(&#39;found&#39; if domain in verified else &#39;not found&#39;),
                        values=resolver.values,
                        ns=resolver.last_nameserver
                    )
                    print(msg)

        # If all our domains have been verified
        if len(verified) == len(self.verification_tokens):
            return True

        # Avoid flooding the DNS server(s)
        time.sleep(interval)

    return False</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.deactivate_account"><code class="name flex">
<span>def <span class="ident">deactivate_account</span></span>(<span>self, delete=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Deactivates the current account registration. This action is irreversible.</p>
<ul>
<li>
<p>:param <code>delete</code> [<code>bool</code>]: indicate whether any associated account file on the local system should also be
deleted after deactivation.</p>
</li>
<li>
<p>:return [<code>none</code>]:</p>
</li>
<li>
<p>:raises <code>InvalidAccount</code>: when account registration has not been set.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.deactivate_account()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deactivate_account(self, delete=True):
    &#34;&#34;&#34;
    Deactivates the current account registration. This action is irreversible.\n
    - :param `delete` [`bool`]: indicate whether any associated account file on the local system should also be
    deleted after deactivation.\n
    - :return [`none`]:\n
    - :raises `InvalidAccount`: when account registration has not been set.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.deactivate_account()
    ```
    &#34;&#34;&#34;
    self.__validate_registration__()

    # Tell the ACME server to deactivate this account
    self.__client__.deactivate_registration(self.account)

    # If this object contains a linked file path, and deletion is requested, delete the linked file
    if self.account_path and delete:
        pathlib.Path(self.account_path).unlink(missing_ok=True)</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.export_account"><code class="name flex">
<span>def <span class="ident">export_account</span></span>(<span>self, save_certificate=True, save_private_key=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the object as a JSON string. This is useful when using a framework like Django and need to store account
data as a string in the database.</p>
<ul>
<li>
<p>:param <code>save_certificate</code> [<code>bool</code>]: indicate whether the certificate should also be stored in the
JSON string.</p>
</li>
<li>
<p>:param <code>save_private_key</code> [<code>bool</code>]: indicate whether the private key should also be stored in the
JSON string.</p>
</li>
<li>
<p>:return [<code>str</code>]: the current object encoded as a JSON string.</p>
</li>
<li>
<p>:raises <code>InvalidAccount</code>: when account registration has not been set.</p>
</li>
<li>
<p>:raises <code>InvalidDomain</code>: when no valid domains are set.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.export_account(save_certificate=True, save_private_key=True)
'{&quot;account&quot;: {&quot;body&quot;: {&quot;key&quot;: {&quot;n&quot;: &quot;vtByzpW...&quot;}}}}'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_account(self, save_certificate=True, save_private_key=False):
    &#34;&#34;&#34;
    Exports the object as a JSON string. This is useful when using a framework like Django and need to store account
    data as a string in the database.\n
    - :param `save_certificate` [`bool`]: indicate whether the certificate should also be stored in the
    JSON string.\n
    - :param `save_private_key` [`bool`]: indicate whether the private key should also be stored in the
    JSON string.\n
    - :return [`str`]: the current object encoded as a JSON string.\n
    - :raises `InvalidAccount`: when account registration has not been set.\n
    - :raises `InvalidDomain`: when no valid domains are set.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.export_account(save_certificate=True, save_private_key=True)
    &#39;{&#34;account&#34;: {&#34;body&#34;: {&#34;key&#34;: {&#34;n&#34;: &#34;vtByzpW...&#34;}}}}&#39;
    ```
    &#34;&#34;&#34;
    self.__validate_registration__()
    self.__validate_domains__()

    # Format our object into a serializable format
    acct_data = {
        &#39;account&#39;: self.account.to_json(),
        &#39;account_key&#39;: self.account_key.json_dumps(),
        &#39;directory&#39;: self.directory,
        &#39;domains&#39;: self.domains,
        &#39;certificate&#39;: self.certificate.decode() if save_certificate else &#39;&#39;,
        &#39;private_key&#39;: self.private_key.decode() if save_private_key else &#39;&#39;
    }

    return json.dumps(acct_data)</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.export_account_to_file"><code class="name flex">
<span>def <span class="ident">export_account_to_file</span></span>(<span>self, path='.', name='account.json', save_certificate=True, save_private_key=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports our object as a JSON file.</p>
<ul>
<li>
<p>:param <code>path</code> [<code>str</code>]: the directory path to save the account file. Defaults to current working directory.</p>
</li>
<li>
<p>:param <code>name</code> [<code>str</code>]: the file name. Defaults to <code>account.json</code>.</p>
</li>
<li>
<p>:param <code>save_certificate</code> [<code>bool</code>]: indicate whether the certificate should also be stored in the JSON file.</p>
</li>
<li>
<p>:param <code>save_private_key</code> [<code>bool</code>]: indicate whether the private key should also be stored in the JSON file.</p>
</li>
<li>
<p>:return [<code>none</code>]: the file will be created at the specified path if an exception was not raised.</p>
</li>
<li>
<p>:raises <code>InvalidPath</code>: when the requested directory path to export the account to does not exist.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.export_account_to_file(
...     path=&quot;/tmp/&quot;,
...     name=&quot;my_acme_account.json&quot;,
...     save_certificate=True,
...     save_private_key=True
... )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_account_to_file(self, path=&#39;.&#39;, name=&#39;account.json&#39;, save_certificate=True, save_private_key=False):
    &#34;&#34;&#34;
    Exports our object as a JSON file.\n
    - :param `path` [`str`]: the directory path to save the account file. Defaults to current working directory.\n
    - :param `name` [`str`]: the file name. Defaults to `account.json`.\n
    - :param `save_certificate` [`bool`]: indicate whether the certificate should also be stored in the JSON file.\n
    - :param `save_private_key` [`bool`]: indicate whether the private key should also be stored in the JSON file.\n
    - :return [`none`]: the file will be created at the specified path if an exception was not raised.\n
    - :raises `InvalidPath`: when the requested directory path to export the account to does not exist.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.export_account_to_file(
    ...     path=&#34;/tmp/&#34;,
    ...     name=&#34;my_acme_account.json&#34;,
    ...     save_certificate=True,
    ...     save_private_key=True
    ... )
    ```
    &#34;&#34;&#34;
    self.__validate_registration__()
    self.__validate_domains__()
    dir_path = pathlib.Path(path).absolute()

    # Ensure our path is an existing directory, throw an error otherwise
    if dir_path.is_dir():
        # Open the file and write our JSON content
        with open(str(dir_path.joinpath(name)), &#39;w&#39;) as (wa):
            wa.write(self.export_account(save_certificate, save_private_key))
            self.account_path = str(dir_path.joinpath(name))
    else:
        msg = &#34;Directory at &#39;{path}&#39; does not exist.&#34;.format(path=path)
        raise errors.InvalidPath(msg)</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.generate_csr"><code class="name flex">
<span>def <span class="ident">generate_csr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a new CSR using the object's <code>domains</code> and <code>private_key</code> values.</p>
<ul>
<li>
<p>:return [<code>bytes</code>]: the encoded CSR PEM data string. This method will update the <code>csr</code> property of the object
with the same value.</p>
</li>
<li>
<p>:raises <code>InvalidDomain</code>: when no valid <code>domains</code> are set.</p>
</li>
<li>
<p>:raises <code>InvalidPrivateKey</code>: when no <code>private_key</code> exists for this object.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.generate_csr()
b'-----BEGIN CERTIFICATE REQUEST-----\nMIHxMIGZAgECMAAwWTATBgckjkn...'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_csr(self):
    &#34;&#34;&#34;
    Generates a new CSR using the object&#39;s `domains` and `private_key` values.\n
    - :return [`bytes`]: the encoded CSR PEM data string. This method will update the `csr` property of the object
    with the same value.\n
    - :raises `InvalidDomain`: when no valid `domains` are set.\n
    - :raises `InvalidPrivateKey`: when no `private_key` exists for this object.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.generate_csr()
    b&#39;-----BEGIN CERTIFICATE REQUEST-----\\nMIHxMIGZAgECMAAwWTATBgckjkn...&#39;
    ```
    &#34;&#34;&#34;
    self.__validate_domains__()
    self.__validate_private_key__()
    self.csr = crypto_util.make_csr(self.private_key, self.domains)
    return self.csr</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.generate_private_key"><code class="name flex">
<span>def <span class="ident">generate_private_key</span></span>(<span>self, key_type='ec256')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a new RSA or EC private key.</p>
<ul>
<li>
<p>:param <code>key_type</code> [<code>str</code>]: the requested <code>private_key</code> type. Options are: [<code>ec256</code>, <code>ec384</code>, <code>rsa2048</code>,
<code>rsa4098</code>]</p>
</li>
<li>
<p>:return [<code>bytes</code>]: the encoded private key PEM data string. This method will update the <code>private_key</code> property
of the object with the same value.</p>
</li>
<li>
<p>:raises <code>InvalidKeyType</code>: when an unknown/unsupported <code>key_type</code> is requested</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.generate_private_key(key_type=&quot;ec384&quot;)
b'-----BEGIN EC PRIVATE KEY-----\nMIGkAgEBBDAZRFNLcQdVJmLh42p8F4D92...'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_private_key(self, key_type=&#39;ec256&#39;):
    &#34;&#34;&#34;
    Generates a new RSA or EC private key.\n
    - :param `key_type` [`str`]: the requested `private_key` type. Options are: [`ec256`, `ec384`, `rsa2048`,
    `rsa4098`]\n
    - :return [`bytes`]: the encoded private key PEM data string. This method will update the `private_key` property
     of the object with the same value.\n
    - :raises `InvalidKeyType`: when an unknown/unsupported `key_type` is requested\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.generate_private_key(key_type=&#34;ec384&#34;)
    b&#39;-----BEGIN EC PRIVATE KEY-----\\nMIGkAgEBBDAZRFNLcQdVJmLh42p8F4D92...&#39;
    ```
    &#34;&#34;&#34;
    # Generate a EC256 private key
    if key_type == &#39;ec256&#39;:
        key = ec.generate_private_key(ec.SECP256R1(), default_backend())
        self.private_key = key.private_bytes(
            encoding=Encoding.PEM,
            format=PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=NoEncryption())
    # Generate a EC384 private key
    elif key_type == &#39;ec384&#39;:
        key = ec.generate_private_key(ec.SECP384R1(), default_backend())
        self.private_key = key.private_bytes(
            encoding=Encoding.PEM,
            format=PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=NoEncryption()
        )
    # Generate a RSA2048 private key
    elif key_type == &#39;rsa2048&#39;:
        key = OpenSSL.crypto.PKey()
        key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048)
        self.private_key = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
    # Generate a RSA4098 private key
    elif key_type == &#39;rsa4098&#39;:
        key = OpenSSL.crypto.PKey()
        key.generate_key(OpenSSL.crypto.TYPE_RSA, 4096)
        self.private_key = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
    # Otherwise, the requested key type is not supported. Throw an error
    else:
        options = [&#39;ec256&#39;, &#39;ec384&#39;, &#39;rsa2048&#39;, &#39;rsa4098&#39;]
        msg = &#34;Invalid private key rtype &#39;{key_type}&#39;. Options {options}&#34;.format(key_type=key_type, options=options)
        raise errors.InvalidKeyType(msg)
    return self.private_key</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.generate_private_key_and_csr"><code class="name flex">
<span>def <span class="ident">generate_private_key_and_csr</span></span>(<span>self, key_type='ec256')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a new private key and CSR.</p>
<ul>
<li>
<p>:param <code>key_type</code> [<code>str</code>]: the requested <code>private_key</code> type. Options are: [<code>ec256</code>, <code>ec384</code>, <code>rsa2048</code>,
<code>rsa4098</code>]</p>
</li>
<li>
<p>:return [<code>tuple</code>]: first value contains the key, the second value contains the CSR. This method will update
the <code>private_key</code> and <code>csr</code> properties of this object with the same values.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.generate_private_key_and_csr(key_type=&quot;rsa2048&quot;)
(b'-----BEGIN PRIVATE KEY-----\nMIIEvAIBA...', b'-----BEGIN CERTIFICATE REQUEST-----\nMIHxM...')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_private_key_and_csr(self, key_type=&#39;ec256&#39;):
    &#34;&#34;&#34;
    Generates a new private key and CSR.\n
    - :param `key_type` [`str`]: the requested `private_key` type. Options are: [`ec256`, `ec384`, `rsa2048`,
    `rsa4098`]\n
    - :return [`tuple`]: first value contains the key, the second value contains the CSR. This method will update
    the `private_key` and `csr` properties of this object with the same values.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.generate_private_key_and_csr(key_type=&#34;rsa2048&#34;)
    (b&#39;-----BEGIN PRIVATE KEY-----\\nMIIEvAIBA...&#39;, b&#39;-----BEGIN CERTIFICATE REQUEST-----\\nMIHxM...&#39;)
    ```
    &#34;&#34;&#34;
    self.generate_private_key(key_type=key_type)
    self.generate_csr()
    return self.private_key, self.csr</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.new_account"><code class="name flex">
<span>def <span class="ident">new_account</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a new ACME account at the set ACME <code>directory</code> URL. By running this method, you are agreeing to the
ACME servers terms of use.</p>
<ul>
<li>
<p>:return [<code>none</code>]: the account and account_key properties will be updated with the new account registration.</p>
</li>
<li>
<p>:raises <code>InvalidDirectory</code>: if this object does not contain a valid ACME directory URL.</p>
</li>
<li>
<p>:raises <code>InvalidEmail</code>: if this object does not contain a valid email address to use during registration.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.new_account()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_account(self):
    &#34;&#34;&#34;
    Registers a new ACME account at the set ACME `directory` URL. By running this method, you are agreeing to the
    ACME servers terms of use.\n
    - :return [`none`]: the account and account_key properties will be updated with the new account registration.\n
    - :raises `InvalidDirectory`: if this object does not contain a valid ACME directory URL.\n
    - :raises `InvalidEmail`: if this object does not contain a valid email address to use during registration.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.new_account()
    ```
    &#34;&#34;&#34;
    self.__validate_directory__()
    self.__validate_email__()

    # Generate a new RSA2048 account key
    rsa_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=(default_backend()))
    self.account_key = jose.JWKRSA(key=rsa_key)

    # Initialize our ACME client object
    self.__net__ = client.ClientNetwork(self.account_key, user_agent=&#39;pyacmedns/1.0.0&#39;)
    self.__directory__ = messages.Directory.from_json(self.__net__.get(self.directory).json())
    self.__client__ = client.ClientV2(self.__directory__, net=self.__net__)

    # Complete registration
    registration = messages.NewRegistration.from_data(email=self.email, terms_of_service_agreed=True)
    self.account = self.__client__.new_account(registration)</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.request_certificate"><code class="name flex">
<span>def <span class="ident">request_certificate</span></span>(<span>self, wait=0, timeout=90)</span>
</code></dt>
<dd>
<div class="desc"><p>Requests a final verification answer from the ACME server and requests the certificate if verification was
successful. If you request the certificate before DNS has propagated and verification fails, you must start
the verification process over entirely by requesting new verification tokens.</p>
<ul>
<li>
<p>:param <code>wait</code> [<code>int</code>]: amount of time (in seconds) to wait before requesting a challenge answer from the
server. This is only necessary if you are not using the <code>check_dns_propagation()</code> method to verify the DNS
records exist and would rather wait a specific amount of time.</p>
</li>
<li>
<p>:return [<code>bytes</code>]: the PEM encoded certificate. This method will update the <code>certificate</code> and <code>csr</code> property
of this object with the same value.</p>
</li>
<li>
<p>:raises <code>InvalidAccount</code>:
when account registration has not been set.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.request_certificate()
b'-----BEGIN CERTIFICATE-----\nMIIEfzCCA2egAwI...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_certificate(self, wait=0, timeout=90):
    &#34;&#34;&#34;
    Requests a final verification answer from the ACME server and requests the certificate if verification was
    successful. If you request the certificate before DNS has propagated and verification fails, you must start
    the verification process over entirely by requesting new verification tokens.\n
    - :param `wait` [`int`]: amount of time (in seconds) to wait before requesting a challenge answer from the
    server. This is only necessary if you are not using the `check_dns_propagation()` method to verify the DNS
    records exist and would rather wait a specific amount of time.\n
    - :return [`bytes`]: the PEM encoded certificate. This method will update the `certificate` and `csr` property
    of this object with the same value.\n
    - :raises `InvalidAccount`:  when account registration has not been set.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.request_certificate()
    b&#39;-----BEGIN CERTIFICATE-----\\nMIIEfzCCA2egAwI...
    ```
    &#34;&#34;&#34;
    self.__validate_verification_tokens__()
    time.sleep(wait)
    deadline = datetime.datetime.now() + datetime.timedelta(seconds=timeout)

    # For each challenge, request an answer.
    for i, c in enumerate(self.__challenges__):
        self.__answers__.append(self.__client__.answer_challenge(c, self.__responses__[i]))

    # Request our final order and save the certificate if successful
    self.__final_order__ = self.__client__.poll_and_finalize(self.__order__, deadline=deadline)
    self.certificate = self.__final_order__.fullchain_pem.encode()
    return self.certificate</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.request_verification_tokens"><code class="name flex">
<span>def <span class="ident">request_verification_tokens</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Requests verification tokens from the ACME server for each <code>domains</code> value. These tokens must be uploaded as
a DNS TXT record for each corresponding domain to complete verification.</p>
<ul>
<li>
<p>:return [<code>list</code>]: a list of tuples containing the challenge FQDN and it's corresponding verification token.</p>
</li>
<li>
<p>:raises <code>InvalidAccount</code>: when account registration has not been set.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.request_verification_tokens()
[
    ('_acme-challenge.test1.example.com', 'moY32lkdsZ3VWHM1mdM...'),
    ('_acme-challenge.test2.example.com', 'asldfkjslweietj23_b...')
]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_verification_tokens(self):
    &#34;&#34;&#34;
    Requests verification tokens from the ACME server for each `domains` value. These tokens must be uploaded as
    a DNS TXT record for each corresponding domain to complete verification.\n
    - :return [`list`]: a list of tuples containing the challenge FQDN and it&#39;s corresponding verification token.\n
    - :raises `InvalidAccount`: when account registration has not been set.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.request_verification_tokens()
    [
        (&#39;_acme-challenge.test1.example.com&#39;, &#39;moY32lkdsZ3VWHM1mdM...&#39;),
        (&#39;_acme-challenge.test2.example.com&#39;, &#39;asldfkjslweietj23_b...&#39;)
    ]
    ```
    &#34;&#34;&#34;
    self.__validate_registration__()
    self.__responses__ = []
    self.__verification_tokens__ = []
    self.__order__ = self.__client__.new_order(self.csr)
    self.__challenges__ = self.__verify_challenge__()

    # Loop through each of our challenges and extract the response and verification token from each
    for i, c in enumerate(self.__challenges__):
        response, validation = c.response_and_validation(self.__client__.net.key)
        self.__responses__.append(response)
        self.__verification_tokens__.append(validation)

    return self.__format_verification_tokens__()</code></pre>
</details>
</dd>
<dt id="pyacmedns.ACMEClient.revoke_certificate"><code class="name flex">
<span>def <span class="ident">revoke_certificate</span></span>(<span>self, reason=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to revoke the existing certificate from the issuing ACME server.</p>
<ul>
<li>
<p>:param <code>reason</code> [<code>int</code>]: the numeric reason for revocation identifier.</p>
</li>
<li>
<p>:return [<code>none</code>]:</p>
</li>
<li>
<p>:raises <code>InvalidCertificate</code>: if this object does not contain a certificate.</p>
</li>
<li>
<p>:raises <code>acme.errors.ConflictError</code>: if the certificate is already revoked.</p>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; client.revoke_certificate()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revoke_certificate(self, reason=0):
    &#34;&#34;&#34;
    Attempts to revoke the existing certificate from the issuing ACME server.\n
    - :param `reason` [`int`]: the numeric reason for revocation identifier.\n
    - :return [`none`]:\n
    - :raises `InvalidCertificate`: if this object does not contain a certificate.\n
    - :raises `acme.errors.ConflictError`: if the certificate is already revoked.\n\n

    ## Example\n
    ```python
    &gt;&gt;&gt; client.revoke_certificate()
    ```
    &#34;&#34;&#34;
    self.__validate_certificate__()

    # Load the certificate crypto object and request revocation from the ACME server
    cert_obj = jose.ComparableX509(OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, self.certificate))
    self.__client__.revoke(cert_obj, reason)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyacmedns.errors" href="errors/index.html">pyacmedns.errors</a></code></li>
<li><code><a title="pyacmedns.tools" href="tools/index.html">pyacmedns.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyacmedns.ACMEClient" href="#pyacmedns.ACMEClient">ACMEClient</a></code></h4>
<ul class="">
<li><code><a title="pyacmedns.ACMEClient.check_dns_propagation" href="#pyacmedns.ACMEClient.check_dns_propagation">check_dns_propagation</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.deactivate_account" href="#pyacmedns.ACMEClient.deactivate_account">deactivate_account</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.export_account" href="#pyacmedns.ACMEClient.export_account">export_account</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.export_account_to_file" href="#pyacmedns.ACMEClient.export_account_to_file">export_account_to_file</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.generate_csr" href="#pyacmedns.ACMEClient.generate_csr">generate_csr</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.generate_private_key" href="#pyacmedns.ACMEClient.generate_private_key">generate_private_key</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.generate_private_key_and_csr" href="#pyacmedns.ACMEClient.generate_private_key_and_csr">generate_private_key_and_csr</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.load_account" href="#pyacmedns.ACMEClient.load_account">load_account</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.load_account_from_file" href="#pyacmedns.ACMEClient.load_account_from_file">load_account_from_file</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.new_account" href="#pyacmedns.ACMEClient.new_account">new_account</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.request_certificate" href="#pyacmedns.ACMEClient.request_certificate">request_certificate</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.request_verification_tokens" href="#pyacmedns.ACMEClient.request_verification_tokens">request_verification_tokens</a></code></li>
<li><code><a title="pyacmedns.ACMEClient.revoke_certificate" href="#pyacmedns.ACMEClient.revoke_certificate">revoke_certificate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>